package ch12_Generics_Enum_Annotation;

//      애너테이션이란, 프로그래밍 언어에 영향을 미치지 않으면서 유용한 정보를 제공해주는 것이다.
//      스프링이나 Servlet 을 사용할 때 애너테이션이 작동하는 원리를 알고 사용하면 더 유익할 것이다.

//      예전에는 소스코드를 작성하면 이 프로그램에 대한 문서를 따로 작성했었다. 어떤 메서드가 있고,
//      메서드의 기능은 뭐고 등등...
//      그런데 만약 소스코드를 변경하고 나면? 그 문서도 같이 변경시키고 버전을 맞춰주어야 했다.
//
//      그런데 현업에서는 급하다 보니 소스코드만 변경하고 문서를 변경시키지 않는 일이 자주 발생했었다.
//      그래서 관리가 안 되다 보니 이 문서랑 소스코드를 합치는 방향으로 갔다.
//      소스코드 위에 주석을 넣기 시작한 것이다. 그게 javadoc.exe 란 프로그램이다.
//      이 프로그램이 소스파일에 있는 주석을 추출해서 별도의 문서를 만들었다.
//
//      애너테이션의 경우는, 프로그램의 소스코드가 있으면 설정 파일이 따로 있었다. 대부분이 xml 이었다.
//      그러나 xml 도 소스코드와 분리되어 있다 보니 어려움이 있었다. 그래서 애너테이션도 합쳤다.
//      이 애너테이션은 JUnit 이라는 특정 프로그램을 위해 존재했던 표기였다.
//      예전에는 프로그램 설정을 xml 에 담았지만 요즘은 안 쓰는 추세고, 애너테이션으로 프로그램에 심는 식으로
//      바뀌어 가고 있다.
//      xml 의 또 다른 문제는 설정 파일은 하나인데 여러 사람이 공유해야 한다는 점이다.
//
//      애너테이션에 대한 내용은 Annotation.java 라는 소스코드 파일에 있다.
//      그 파일을 보면 public interface Annotation 인터페이스가 선언되어 있다.
//      애너테이션은 javadoc.exe 에 유용한 정보를 제공하기 위해 존재하는 것이다.
//
//      애너테이션의 예시:
//      @Test           // 이 메서드가 테스트 대상임을 단위 테스트 프로그램(JUnit)에게 알리는 기능
//
//
//      "표준 에너테이션" 이라는 것도 있다. 이는 Java 에서 제공하는 애너테이션이다.
//      표준 애너테이션에는 다음과 같은 것들이 있다.
//      @Override               컴파일러에게 오버라이딩하는 메서드라는 것을 알린다.
//
//      @Deprecated             앞으로 사용하지 않을 것을 권장하는 대상에 붙인다.
//
//      @SuppressWarnings       컴파일러의 특정 경고메시지가 나타나지 않게 해준다.
//
//      @SafeVarargs            지네릭스 타입의 가변인자에 사용한다.
//
//      @FunctionalInterface    함수형 인터페이스라는 것을 알린다.
//
//      @Native                 native 메서드에서 참조되는 상수 앞에 붙인다.
//

//      이 아래부터는 "메타 애너테이션"이다. 메타 애너테이션은 애너테이션을 만들 때 사용하는 애너테이션이다.
//      (사실 얘네들은 거의 쓸 일이 없어서 몰라도 상관없긴 함)
//      @Target                 애너테이션이 적용가능한 대상을 지정하는 데 사용
//
//      @Documented             애너테이션 정보가 javadoc 으로 작성된 문서에 포함되게 함
//
//      @Inherited              애너테이션이 자손 클래스에 상속되도록 함
//
//      @Retention              애너테이션이 유지되는 범위를 지정할 때 사용
//
//      @Repeatable             애너테이션을 반복해서 적용할 수 있게 함
//
//

public class _12_Annotation {
}
