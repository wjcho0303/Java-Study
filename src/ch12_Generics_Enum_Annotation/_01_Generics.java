package ch12_Generics_Enum_Annotation;

//      지네릭스는 compile 할 때 타입을 체크해주는 기능으로, JDK 1.5 부터 사용이 가능해졌다.
//      이전에도 컴파일 할 때 타입을 체크해주긴 했으나 지금보다는 한계가 있었다.
//
//      예를 들어 ArrayList 에는 오브젝트가 들어갈 수 있어서, 모든 객체를 저장할 수 있었다.
//      그런데 만약 특정 Object, 예를 들어 Tv 라는 클래스의 객체만 넣고 싶다면 어떻게 했을까?
//      예전에는 Tv 가 아닌 다른 걸 집어넣어도 잡아낼 방법이 없었다. 컴파일러가 에러를 잡아내지 못해서
//      실행 시에 에러가 발생하곤 하였다.
//
//      그러나 이제는 지네릭스를 통해 <Tv> 이런 식으로 타입을 지정해주고 객체를 생성하면 그 ArrayList 에는 Tv만
//      저장할 수 있게 된다. 다른 타입의 객체를 넣으려고 하면 컴파일러가 에러 메세지를 띄운다.
//
//      ArrayList list = new ArrayList();
//      예전에는 이렇게 썼다면,
//
//      ArrayList<Tv> list = new ArrayList<Tv>();
//      이제는 이렇게 지네릭스를 활용하여 쓴다.
//      이렇게 컬렉션 프레임워크 바로 다음에 꺽쇄 <>를 쓰고 그 안에다가 어떤 객체 타입만 허용되는지 적어준다.
//      예를 들어 Tv 가 아니라 Integer 나 String 을 저 기호 안에 넣으면 그 타입의 객체만 들어갈 수 있고,
//      만약 다른 타입의 객체를 집어넣으려고 하면 빨간 줄이 그어지면서 에러 알림이 발생한다.
//
//
//      지네릭스의 또 다른 장점은, 타입 체크가 강화되어 기본형 자료들의 경우 형변환을 생략할 수 있다.
//      예를 들어 ArrayList<Integer> list 의 경우, list.add("30"); 이렇게 30을 String 으로 집어넣어도
//      알아서 Integer 로 형변환 시켜준다.
//
//      그리고 지네릭스 칸에 <Object> 이렇게 넣으면 모든 종류의 객체가 들어갈 수 있다.
//      ??? 아까는 한 종류만 들어갈 수 있다고 했는데? ㄴㄴ 입력한 객체의 자손들은 들어갈 수 있다.
//      근데 Object 는 모든 객체의 조상 클래스이므로 <Object> 딱 이렇게 해버리면 모든 객체가 들어갈 수 있게 되는 것이다.
//
//      사실 지금까지 <Object> 를 안 쓰고 그냥 아래처럼 쓰긴 했는데...
//      ArrayList list = new ArrayList();
//
//      사실 JDK1.5 이후부터는 저렇게 하면 안 된다. 에러가 나는 건 아닌데 좋은 코드는 아니다.
//      지네릭스가 도입된 이후부터는 아무 객체나 다 들어가게 하고 싶다면 반드시 <Object> 이걸 써 넣야 한다.
//      ArrayList<Object> list = new ArrayList<Object>();
//
//      이렇게, 지네릭스는 객체 타입의 안정성을 높여주고,
//      타입체크와 형변환을 생략할 수 있어서 코드를 간결하게 해준다.
//
//      사실 지네릭스가 나온 이유 자체가 런타임 에러를 컴파일 에러 영역으로 끌어들여서 프로그램의
//      안정성을 높이기 위한 것이다.
//
//


public class _01_Generics {
    public static void main(String[] args) {

    }
}
