package ch06_OOP1;

// static 의 핵심은 "객체없이 사용"하는 것이다. 반복해서 따라해보자.
// "static"은 "객체 없이"
    // "static"은 "객체 없이"
        // "static"은 "객체 없이"
            // "static"은 "객체 없이"
                // "static"은 "객체 없이"

// 그러므로 static 변수와 static 메서드는 해당 클래스의 객체 생성 없이도 사용이 가능하고 이해해두면 된다.
// 특정 메서드를 설계할 때, 객체 생성 없이 호출이 가능하게 하고 싶다면 static 키워드를 추가해주면 된다.

class Card {
    String kind;        // 카드마다 모양이 다를 수 있으므로 개별적인 속성이다. 인스턴스 변수이다.
    int num;            // 카드마다 숫자가 다를 수 있으므로 개별적인 속성이다. 인스턴스 변수이다.
    static int width;   // 모든 객체가 100 값을 가져야 함
    //  int width;
    // 모든 카드 객체들이 공통적으로 같은 값을 가져야 하는 속성이다. 이런 속성이 클래스 변수로 사용된다.

    static int height;  // 모든 객체가 250 값을 가져야 함
    //  int height;
    // 모든 카드 객체들이 공통적으로 같은 값을 가져야 하는 속성이다. 이런 속성이 클래스 변수로 사용된다.

    // 이렇게 모든 객체들이 동일해야 하는 속성을 가지는 필드는 static 키워드를 앞에 선언해준다.

    public void method() {
        int lv = 0;     // 지역변수 (메서드 밖에서 사용 불가)
    }

    public static int staticMethod() {
        int cardLength = 2*width + 2*height;
        return cardLength;
    }
    public Card () {

    };
}

    // static 변수에 접근할 때는 리모컨을 인스턴스로 사용하면 안 된다.
    // 즉, static 멤버변수에 접근할 때는 인스턴스의 참조변수를 사용하면 안 되고, 클래스명으로 호출해야 한다.
    // 예를 들어, main 메서드에서 static 변수의 값을 수정한다고 해보자.

public class _05_StaticVariable {
    public static void main(String[] args) {

        Card c1 = new Card();
        c1.kind = "Heart";
        c1.num = 7;
//      c1.width = 200;
//      c1.height = 300;
        // 이렇게 static 변수에 접근할 때 인스턴스 참조변수(c1)로 접근하면 오류가 발생하진 않지만 올바른 방법은 아니다.
        // 왜냐하면 다른 사람이 보면 일반 인스턴스 변수인 것으로 착각할 수도 있기 때문이다.

        // 그리고 사실 이렇게 인스턴스로 호출 자체는 가능하지만 메모리 상에서 객체가 실제로 이 값을 보유한 것은 아니다.
        // 객체들이 모두 이 필드를 직접 보유하게 되면 메모리 낭비일 것이다.
        // c1.width 이렇게 하는 것은 객체들이 static 변수에 접근하는 것처럼 보이지만
        // 사실 실제로는 클래스 이름으로 접근하는 것이다. 컴파일러가 클래스 이름으로 접근하도록 자동으로 변환해주는 것일 뿐이다.
        // 그러나 이런 식으로 접근하는 것은 바람직하지 않은 프로그래밍 관행이다.

        Card.width = 100;
        Card.height = 250;
        // static 변수에 접근할 때는 이렇게 리모컨을 해당 static 변수의 클래스명(Card)으로 호출해야 한다.
        // static 변수가 메모리에 로딩되는 과정은 플래시 동영상을 참고한다.

        // 참고1: static 메서드에는 그 static 메서드의 지역변수와 static 변수만 들어가도록 설계해야 한다.
        // 참고2: 인스턴스 변수와 인스턴스 메서드는 인스턴스가 생성되기 전에는 실제로 존재하지 않는다. (설계도에만 있을 뿐)

        // static 메서드는 클래스명에다가 점을 찍고 클래스명.메서드 사용하는 메서드이다.
        // 그리고 static 메서드는 클래스에 소속된 메서드이기 때문에 인스턴스를 생성하지 않아도 사용할 수 있어야 한다.
        // 인스턴스 변수는 인스턴스를 생성하지 않으면 아예 존재하지 않는다.
        // 그런데 static 메서드에 인스턴스 변수를 넣어버리면, 인스턴스를 만들지 않은 상태에서 호출해버린다면
        // 메서드가 인스턴스 변수를 찾지 못해 에러가 발생할 것이다.
        // 그래서 static 메서드에는 그 static 메서드의 지역변수와 static 변수'만' 들어가도록 설계해야 한다.

        // 예를 들어 Math.random() 이라는 static 메서드를 생각해보자. 지금까지 공부하면서
        // Math 객체를 생성한 다음에 m.random() 이런 식으로 호출한 적이 없었다.
        // 그냥 바로 Math 라는 클래스가 가진 random() 메서드를 바로 호출해왔다.
        // 이렇게 할 수 있었던 이유는 random() 메서드가 static 메서드이기 때문이다. Arrays.toString() 같은 메서드들도 마찬가지다.

        // 만약 random() 메서드 구현부에 Math 객체의 인스턴스 변수가 있었다고 하자.
        // 인스턴스 변수가 메서드의 로직에 들어가 있었다면 호출하는 Math 객체가 없으면 그 객체의 인스턴스 변수를 찾을 수 없게 되어
        // 에러가 발생했을 것이다.
        // 그렇기 때문에 애초부터 static 메서드를 설계할 때 지역변수와 static 변수만 포함하도록 설계해놓은 것이다.

        // 추가로, 같은 이유로 static 메서드 안에는 당연히 일반 인스턴스 메서드를 넣을 수도 없다.
        // 인스턴스 멤버변수나 인스턴스 메서드나 둘 다 객체가 생성될 때 함께 생성된다. 그 전에는 실제로 존재하지 않는다.
        // static 메서드 안에 인스턴스 메서드를 호출하도록 구현해버리면 객체를 생성하도록 강요하는 게 되어 버린다.
        // 결국 static 이라는 키워드의 핵심은 "객체를 생성하지 않아도 접근할 수 있어야 한다"라고 보면 된다.
        // 이해 여부와 별개로, static 메서드에는 오직 지역변수와 static 변수만 포함시킬 수 있다는 것을 외워두는 것이 좋다.

        // static 키워드가 붙은 것들은 해당 클래스 파일이 메모리에 로딩될 때 같이 올라가기 때문에
        // 객체가 생성되지 않아도 사용할 수 있다.

        System.out.printf("모든 카드들은 공통적으로 총 둘레가 %d 입니다.%n", Card.staticMethod());
        // 모든 카드들은 공통적으로 총 둘레가 700 입니다.

        // * 여담으로, 사실 Math 클래스의 생성자가 private 접근제어자가 붙어있어 객체를 생성할 수도 없다.
        // 또, c1.staticMethod() 이런 식으로 인스턴스를 통해 static 메서드를 호출하는 것도 가능하기는 하다.
        // 그러나 이 역시 마찬가지로 권장되지 않는 방법이다. 다른 사람이 보기에 인스턴스 메서드로 착각할 수 있기 때문이다.
    }
}
